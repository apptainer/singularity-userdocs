

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Introduction &mdash; Singularity container 2.6 documentation</title>




    <link rel="shortcut icon" href="_static/favicon.png"/>












  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Installation" href="installation.html" />
    <link rel="prev" title="Quick Start" href="quick_start.html" />


  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">


  <div class="wy-grid-for-nav">


    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">



            <a href="index.html" class="icon icon-home"> Singularity container




            <img src="_static/logo.png" class="logo" alt="Logo"/>

          </a>




              <div class="version">
                2.6
              </div>




<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">






              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quick_start.html">Quick Start</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#welcome-to-singularity">Welcome to Singularity!</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mobility-of-compute">Mobility of Compute</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reproducibility">Reproducibility</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-freedom">User Freedom</a></li>
<li class="toctree-l3"><a class="reference internal" href="#support-on-existing-traditional-hpc">Support on Existing Traditional HPC</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#a-high-level-view-of-singularity">A High Level View of Singularity</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#security-and-privilege-escalation">Security and privilege escalation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-singularity-container-image">The Singularity container image</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#copying-sharing-branching-and-distributing-your-image"><em>Copying, sharing, branching, and distributing your image</em></a></li>
<li class="toctree-l4"><a class="reference internal" href="#supported-container-formats"><em>Supported container formats</em></a></li>
<li class="toctree-l4"><a class="reference internal" href="#supported-uniform-resource-identifiers-uri"><em>Supported Uniform Resource Identifiers (URI)</em></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#name-spaces-and-isolation">Name-spaces and isolation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compatibility-with-standard-work-flows-pipes-and-io">Compatibility with standard work-flows, pipes and IO</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-singularity-process-flow">The Singularity Process Flow</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-singularity-usage-workflow">The Singularity Usage Workflow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#singularity-commands">Singularity Commands</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#support">Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="#about">About</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#background">Background</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-singularity-solution">The Singularity Solution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#portability-and-reproducibility">Portability and Reproducibility</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#features">Features</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#encapsulation-of-the-environment">Encapsulation of the environment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#containers-are-image-based">Containers are image based</a></li>
<li class="toctree-l4"><a class="reference internal" href="#no-user-contextual-changes-or-root-escalation-allowed">No user contextual changes or root escalation allowed</a></li>
<li class="toctree-l4"><a class="reference internal" href="#no-root-owned-daemon-processes">No root owned daemon processes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#use-cases">Use Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#byoe-bring-your-own-environment">BYOE: Bring Your Own Environment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reproducible-science">Reproducible science</a></li>
<li class="toctree-l4"><a class="reference internal" href="#static-environments-software-appliances">Static environments (software appliances)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#legacy-code-on-old-operating-systems">Legacy code on old operating systems</a></li>
<li class="toctree-l4"><a class="reference internal" href="#complicated-software-stacks-that-are-very-host-specific">Complicated software stacks that are very host specific</a></li>
<li class="toctree-l4"><a class="reference internal" href="#complicated-work-flows-that-require-custom-installation-and-or-data">Complicated work-flows that require custom installation and/or data</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#license">License</a></li>
<li class="toctree-l3"><a class="reference internal" href="#getting-started">Getting started</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="build_a_container.html">Build a Container</a></li>
<li class="toctree-l1"><a class="reference internal" href="build_environment.html">Build Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="container_recipes.html">Container Recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="singularity_flow.html">Singularity Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="bind_paths_and_mounts.html">Bind Paths and Mounts</a></li>
<li class="toctree-l1"><a class="reference internal" href="persistent_overlays.html">Persistent Overlays</a></li>
<li class="toctree-l1"><a class="reference internal" href="running_services.html">Running Services</a></li>
<li class="toctree-l1"><a class="reference internal" href="container_checks.html">Container Checks</a></li>
<li class="toctree-l1"><a class="reference internal" href="environment_and_metadata.html">Environment and Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="reproducible_scif_apps.html">Reproducible SCI-F Apps</a></li>
<li class="toctree-l1"><a class="reference internal" href="singularity_and_docker.html">Singularity and Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix.html">Appendix</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">FAQ</a></li>
</ul>



        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">


      <nav class="wy-nav-top" aria-label="top navigation">

          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Singularity container</a>

      </nav>


      <div class="wy-nav-content">

        <div class="rst-content style-external-links">

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">

      <li><a href="index.html">Docs</a> &raquo;</li>

      <li>Introduction</li>


      <li class="wy-breadcrumbs-aside">



              <a href="https://github.com/singularityware/singularity-userdocs/blob/master/introduction.rst" class="fa fa-github"> Edit on GitHub</a>



      </li>

  </ul>


  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">

  <div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>This document will introduce you to Singularity, If you are viewing this on the web there should be links in the
bar to the left that will direct you to other important topics. If you
want to get a quick overview, see our <a class="reference internal" href="quick_start.html#quick-start"><span class="std std-ref">quickstart</span></a>. If you want to
understand which commands are a best fit for your use case, see our build
flow section. There is also a separate Singularity Administration Guide
that targets system administrators, so if you are a service provider, or
an interested user, it is encouraged that you read that document as
well.</p>
<div class="section" id="welcome-to-singularity">
<h2>Welcome to Singularity!<a class="headerlink" href="#welcome-to-singularity" title="Permalink to this headline">¶</a></h2>
<p>Singularity is a container solution created by necessity for
scientific and application driven workloads.
Over the past decade and a half, virtualization has gone from an
engineering toy to a global infrastructure necessity and the evolution
of enabling technologies has flourished. Most recently, we have seen
the introduction of the latest spin on virtualization… “containers”.
People tend to view containers in light of their virtual machine
ancestry and these preconceptions influence feature sets and expected
use cases. This is both a good and a bad thing…
For industry and enterprise-centric container technologies this is a
good thing. Web enabled cloud requirements are very much in alignment
with the feature set of virtual machines, and thus the preceding
container technologies. But the idea of containers as miniature
virtual machines is a bad thing for the scientific world and
specifically the high performance computation (HPC) community. While
there are many overlapping requirements in these two fields, they
differ in ways that make a shared implementation generally
incompatible. Some groups have leveraged custom-built resources that
can operate on a lower performance scale, but proper integration is
difficult and perhaps impossible with today’s technology.
Many scientists could benefit greatly by using container technology,
but they need a feature set that differs somewhat from that available
with current container technology. This necessity drives the creation
of Singularity and articulated its four primary functions:</p>
<div class="section" id="mobility-of-compute">
<h3>Mobility of Compute<a class="headerlink" href="#mobility-of-compute" title="Permalink to this headline">¶</a></h3>
<p>Mobility of compute is defined as the ability to define, create and
maintain a workflow and be confident that the workflow can be executed
on different hosts, operating systems (as long as it is Linux) and
service providers. Being able to contain the entire software stack,
from data files to library stack, and portably move it from system to
system means true mobility.
Singularity achieves this by utilizing a distributable image format
that contains the entire container and stack into a single file. This
file can be copied, shared, archived, and standard UNIX file
permissions also apply. Additionally containers are portable (even
across different C library versions and implementations) which makes
sharing and copying an image as easy as <code class="docutils literal notranslate"><span class="pre">cp</span></code> or <code class="docutils literal notranslate"><span class="pre">scp</span></code> or <code class="docutils literal notranslate"><span class="pre">ftp</span></code>.</p>
</div>
<div class="section" id="reproducibility">
<h3>Reproducibility<a class="headerlink" href="#reproducibility" title="Permalink to this headline">¶</a></h3>
<p>As mentioned above, Singularity containers utilize a single file which is the complete
representation of all the files within the container. The same
features which facilitate mobility also facilitate reproducibility.
Once a contained workflow has been defined, a snapshot image can be taken of a container.
The image can be then archived and locked down such that it can be used later
and you can be confident that the code within the container has not
changed.</p>
</div>
<div class="section" id="user-freedom">
<h3>User Freedom<a class="headerlink" href="#user-freedom" title="Permalink to this headline">¶</a></h3>
<p>System integrators, administrators, and engineers spend a lot
of effort maintaining their systems, and tend to take a cautious
approach. As a result, it is common to see hosts installed with
production, mission critical operating systems that are “old” and have
few installed packages. Users may find software or libraries that are
too old or incompatible with the software they must run, or the
environment may just lack the software stack they need due to
complexities with building, specific software knowledge,
incompatibilities or conflicts with other installed programs.</p>
<p>Singularity can give the user the freedom they need to install the
applications, versions, and dependencies for their workflows without
impacting the system in any way. Users can define their own working
environment and literally copy that environment image (single file) to
a shared resource, and run their workflow inside that image.</p>
</div>
<div class="section" id="support-on-existing-traditional-hpc">
<h3>Support on Existing Traditional HPC<a class="headerlink" href="#support-on-existing-traditional-hpc" title="Permalink to this headline">¶</a></h3>
<p>Replicating a virtual machine cloud like environment within an
existing HPC resource is not a reasonable goal for many
administrators. There are a lots of container systems available which
are designed for enterprise, as a replacement for virtual machines,
are cloud focused, or require unstable or unavailable kernel features.
Singularity supports existing and traditional HPC resources as easily
as installing a single package onto the host operating system. Custom
configurations may be achieved via a single configuration file, and
the defaults are tuned to be generally applicable for shared
environments.
Singularity can run on host Linux distributions from RHEL6 (RHEL5 for
versions lower than 2.2) and similar vintages, and the contained
images have been tested as far back as Linux 2.2 (approximately 14
years old). Singularity natively supports InfiniBand, Lustre, and
works seamlessly with all resource managers (e.g. SLURM, Torque, SGE,
etc.) because it works like running any other command on the system.
It also has built-in support for MPI and for containers that need to
leverage GPU resources.</p>
</div>
</div>
<div class="section" id="a-high-level-view-of-singularity">
<h2>A High Level View of Singularity<a class="headerlink" href="#a-high-level-view-of-singularity" title="Permalink to this headline">¶</a></h2>
<div class="section" id="security-and-privilege-escalation">
<span id="id1"></span><h3>Security and privilege escalation<a class="headerlink" href="#security-and-privilege-escalation" title="Permalink to this headline">¶</a></h3>
<p>A user inside a Singularity container
is the same user as outside the container
This is one of Singularities defining characteristics. It allows a
user (that may already have shell access to a particular host) to
simply run a command inside of a container image as themselves. The following example
scenario will help illustrate a Singularity container:</p>
<p>%SERVER and %CLUSTER are large expensive systems with resources far
exceeding those of my personal workstation. But because they are
shared systems, no users have root access. The environments are
tightly controlled and managed by a staff of system administrators.
To keep these systems secure, only the system administrators are
granted root access and they control the state of the operating
systems and installed applications. If a user is able to escalate to
root (even within a container) on %SERVER or %CLUSTER, they can do
bad things to the network, cause denial of service to the host (as
well as other hosts on the same network), and may have unrestricted
access to file systems reachable by the container.</p>
<p>To mitigate security concerns like this, Singularity limits one’s
ability to escalate permission inside a container. For example, if I
do not have root access on the target system, I should not be able to
escalate my privileges within the container to root either. This is
semi-antagonistic to Singularity’s 3rd tenant; allowing the users to
have freedom of their own environments. Because if a user has the
freedom to create and manipulate their own container environment,
surely they know how to escalate their privileges to root within that
container. Possible means to escalation could include setting the root user’s password,
or enabling themselves to have sudo access. For these reasons,
Singularity prevents user context escalation within the container, and
thus makes it possible to run user supplied containers on shared
infrastructures.
This mitigation dictates the <a class="reference internal" href="singularity_flow.html#singularity-flow"><span class="std std-ref">Singularity workflow</span></a>. If a user needs to be root
in order to make changes to their containers, then they need to have
an endpoint (a local workstation, laptop, or server) where they have
root access. Considering almost everybody at least has a laptop, this
is not an unreasonable or unmanageable mitigation, but it must be
defined and articulated.</p>
</div>
<div class="section" id="the-singularity-container-image">
<h3>The Singularity container image<a class="headerlink" href="#the-singularity-container-image" title="Permalink to this headline">¶</a></h3>
<p>Singularity makes use of a container image
file, which physically includes the container. This file is a physical
representation of the container environment itself. If you obtain an
interactive shell within a Singularity container, you are literally
running within that file.
This design simplifies management of files to the element of least surprise,
basic file permission. If you either own a container image, or have
read access to that container image, you can start a shell inside that
image. If you wish to disable or limit access to a shared image, you
simply change the permission ACLs to that file.
There are numerous benefits for using a single file image for the
entire container:</p>
<ul class="simple">
<li>Copying or branching an entire container is as simple as <code class="docutils literal notranslate"><span class="pre">cp</span></code></li>
<li>Permission/access to the container is managed via standard file
system permissions</li>
<li>Large scale performance (especially over parallel file systems) is
very efficient</li>
<li>No caching of the image contents to run (especially nice on clusters)</li>
<li>Containers are compressed and consume very little disk space</li>
<li>Images can serve as stand-alone programs, and can be executed like
any other program on the host</li>
</ul>
<div class="section" id="copying-sharing-branching-and-distributing-your-image">
<h4><em>Copying, sharing, branching, and distributing your image</em><a class="headerlink" href="#copying-sharing-branching-and-distributing-your-image" title="Permalink to this headline">¶</a></h4>
<p>A primary goal of Singularity is mobility. The single file image
format makes mobility easy. Because Singularity images are single
files, they are easily copied and managed. You can copy the image to
create a branch, share the image and distribute the image as easily as
copying any other file you control!</p>
<p>If you want an automated solution for building and hosting your image,
you can use our container registry <a class="reference external" href="https://singularity-hub.org/">Singularity Hub</a>. Singularity Hub
can automatically build <a class="reference internal" href="container_recipes.html#container-recipes"><span class="std std-ref">Singularity recipe files</span></a> from
a GitHub repository each time that you push. It provides a simple cloud
solution for storing and sharing your image. If you want to host your own
Registry, then you should check out <a class="reference external" href="https://www.github.com/singularityhub/sregistry">Singularity Registry</a>.
If you have ideas or suggestions for how Singularity can better support
reproducible science, please <a class="reference external" href="https://www.sylabs.io/contact/">reach out!</a>.</p>
</div>
<div class="section" id="supported-container-formats">
<h4><em>Supported container formats</em><a class="headerlink" href="#supported-container-formats" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><strong>squashfs</strong>: the default container format is a compressed read-only
file system that is widely used for things like live CDs/USBs and
cell phone OS’s</li>
<li><strong>ext3</strong>: (also called <code class="docutils literal notranslate"><span class="pre">writable</span></code>) a writable image file containing an ext3
file system that was the default container format prior to
Singularity version 2.4</li>
<li><strong>directory</strong>: (also called <code class="docutils literal notranslate"><span class="pre">sandbox</span></code>) standard Unix directory containing a
root container image</li>
<li><strong>tar.gz</strong>: zlib compressed tar archive</li>
<li><strong>tar.bz2</strong>: bzip2 compressed tar archive</li>
<li><strong>tar</strong>: uncompressed tar archive</li>
</ul>
</div>
<div class="section" id="supported-uniform-resource-identifiers-uri">
<h4><em>Supported Uniform Resource Identifiers (URI)</em><a class="headerlink" href="#supported-uniform-resource-identifiers-uri" title="Permalink to this headline">¶</a></h4>
<p>Singularity also supports several different mechanisms for obtaining the
images using a standard URI format.</p>
<ul class="simple">
<li><strong>shub://</strong> Singularity Hub is our own registry for Singularity
containers. If you want to publish a container, or give easy access
to others from their command line, or enable automatic builds, you
should build it on <a class="reference external" href="https://singularity-hub.org/">Singularity Hub</a>.</li>
<li><strong>docker://</strong> Singularity can pull Docker images from a Docker
registry, and will run them non-persistently (e.g. changes are not
persisted as they can not be saved upstream). Note that pulling a
Docker image implies assembling layers at runtime, and two subsequent
pulls are not guaranteed to produce an identical image.</li>
<li><strong>instance://</strong> A Singularity container running as service, called an
instance, can be referenced with this URI.</li>
</ul>
</div>
</div>
<div class="section" id="name-spaces-and-isolation">
<h3>Name-spaces and isolation<a class="headerlink" href="#name-spaces-and-isolation" title="Permalink to this headline">¶</a></h3>
<p>When asked, “What namespaces does Singularity virtualize?”, the most
appropriate response from a Singularity point of view is “As few as
possible!”. This is because the goals of Singularity are mobility,
reproducibility and freedom, not full isolation (as you would expect
from industry driven container technologies). Singularity only
separates the needed namespaces in order to satisfy our primary goals.</p>
<p>Coupling incomplete isolation with the fact that a user inside a
container is the same user outside the container, allows Singularity
to blur the lines between a container and the underlying host system.
Using Singularity feels like running in a parallel universe, where
there are two time lines. In one time line, the system administrators
installed their operating system of choice. But on an alternate
time line, we bribed the system administrators and they installed our
favorite operating system and apps, and gave us full control but
configured the rest of the system identically. And Singularity gives
us the power to pick between these two time lines.
In other words, Singularity allows you to virtually swap out the
underlying operating system for one that you’ve defined without
affecting anything else on the system and still having all of the host
resources available to you.</p>
<p>The container is similar to logging into another identical host running
a different operating system. e.g. One moment you are on Centos-6 and the next minute
you are on the latest version of Ubuntu that has Tensorflow installed,
or Debian with the latest OpenFoam, or a custom workflow that you
installed. But you are still the same user with the same files running
the same PIDs.
Additionally, the selection of name-space virtualization can be
dynamic or conditional. For example, the PID namespace is not
separated from the host by default, but if you want to separate it,
you can with a command line (or environment variable) setting. You can
also decide if you want to contain a process so it can not reach out to
the host file system if you don’t know if you trust the image. But by
default, you are allowed to interface with all of the resources,
devices and network inside the container as you are outside the
container (given your level of permissions).</p>
</div>
<div class="section" id="compatibility-with-standard-work-flows-pipes-and-io">
<h3>Compatibility with standard work-flows, pipes and IO<a class="headerlink" href="#compatibility-with-standard-work-flows-pipes-and-io" title="Permalink to this headline">¶</a></h3>
<p>Singularity abstracts the complications of running an application in
an environment that differs from the host. For example, applications
or scripts within a Singularity container can easily be part of a
pipeline that is being executed on the host. Singularity containers
can also be executed from a batch script or other program (e.g. an HPC
system’s resource manager) natively.
Some usage examples of Singularity can be seen as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ singularity exec dummy.img xterm  # run xterm from within the container

$ singularity exec dummy.img python script.py  # run a script on the host system using container&#39;s python

$ singularity exec dummy.img python &lt; /path/to/python/script.py  # do the same via redirection

$ cat /path/to/python/script.py | singularity exec dummy.img python  # do the same via a pipe
</pre></div>
</div>
<p>You can even run MPI executables within the container as simply as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ mpirun -np X singularity exec /path/to/container.img /usr/bin/mpi_program_inside_container (mpi program args)
</pre></div>
</div>
</div>
<div class="section" id="the-singularity-process-flow">
<h3>The Singularity Process Flow<a class="headerlink" href="#the-singularity-process-flow" title="Permalink to this headline">¶</a></h3>
<p>When executing container commands, the Singularity process flow can be
generalized as follows:</p>
<ol class="arabic simple">
<li>Singularity application is invoked</li>
<li>Global options are parsed and activated</li>
<li>The Singularity command (subcommand) process is activated</li>
<li>Subcommand options are parsed</li>
<li>The appropriate sanity checks are made</li>
<li>Environment variables are set</li>
<li>The Singularity Execution binary is called (<code class="docutils literal notranslate"><span class="pre">sexec</span></code>)</li>
<li>Sexec determines if it is running privileged and calls the <code class="docutils literal notranslate"><span class="pre">SUID</span></code> code if
necessary</li>
<li>Namespaces are created depending on configuration and process
requirements</li>
<li>The Singularity image is checked, parsed, and mounted in the
namespace</li>
<li>Bind mount points are setup so that files on the host are visible in
the <code class="docutils literal notranslate"><span class="pre">CLONE_NEWNS</span></code> container</li>
<li>The namespace <code class="docutils literal notranslate"><span class="pre">CLONE_FS</span></code> is used to virtualize a new root file system</li>
<li>Singularity calls <code class="docutils literal notranslate"><span class="pre">execvp()</span></code> and Singularity process itself is replaced by the
process inside the container</li>
<li>When the process inside the container exits, all namespaces collapse
with that process, leaving a clean system</li>
</ol>
<p>All of the above steps are fast and seem instantaneous to the user (i.e. there is little run-time overhead), when measured on a standard server the overhead was approximately 15-25 thousandths of a second).</p>
</div>
</div>
<div class="section" id="the-singularity-usage-workflow">
<h2>The Singularity Usage Workflow<a class="headerlink" href="#the-singularity-usage-workflow" title="Permalink to this headline">¶</a></h2>
<p>The security model of Singularity (as described above, <a class="reference internal" href="#security-and-privilege-escalation"><span class="std std-ref">“A user inside a Singularity container is the same user as outside the container”</span></a>) defines the
Singularity workflow. There are generally two groups of actions you
must implement on a container; management (building your container)
and usage.</p>
<p>In many circumstances building containers require root administrative
privileges just like these actions would require on any system,
container, or virtual machine. This means that a user must have access
to a system on which they have root privileges. This could be a
server, workstation, a laptop, virtual machine, or even a cloud
instance. If you are using OS X or Windows on your laptop, it is
recommended to setup Vagrant, and run Singularity from there (there
are recipes for this which can be found at the Singularity website.
Once you have Singularity installed on your endpoint of choice, this
is where you will do the bulk of your container development. This
workflow can be described visually as follows:</p>
<div class="figure" id="id4">
<img alt="Singularity workflow" src="_images/flow.png" />
<p class="caption"><span class="caption-text">Singularity workflow</span></p>
</div>
<p>On the left side, you have your build environment: a laptop,
workstation, or a server that you control. Here you will (optionally):</p>
<ol class="arabic simple">
<li>develop and test containers using <code class="docutils literal notranslate"><span class="pre">--sandbox</span></code> (build into a writable directory)
or <code class="docutils literal notranslate"><span class="pre">--writable</span></code> (build into a writable ext3 image)</li>
<li>build your production containers with a squashfs filesystem.</li>
</ol>
<p>Once you have the container with the necessary applications, libraries
and data inside it can be easily shared to other hosts and executed
without requiring root access. A production container should be an
immutable object, so if you need to make changes to your container you
should go back to your build system with root privileges, rebuild the
container with the necessary changes, and then re-upload the container
to the production system where you wish to run it.</p>
<div class="section" id="singularity-commands">
<h3>Singularity Commands<a class="headerlink" href="#singularity-commands" title="Permalink to this headline">¶</a></h3>
<p>How do the commands work?</p>
<p>The following is a list of the Singularity commands, Click on each command for more information.</p>
<ul class="simple">
<li><a class="reference internal" href="appendix.html#build-command"><span class="std std-ref">build</span></a> : Build a container on your user endpoint or build environment</li>
<li><a class="reference internal" href="appendix.html#exec-command"><span class="std std-ref">exec</span></a> : Execute a command to your container</li>
<li><a class="reference internal" href="appendix.html#inspect-command"><span class="std std-ref">inspect</span></a> : See labels, run and test scripts, and environment variables</li>
<li><a class="reference internal" href="appendix.html#pull-command"><span class="std std-ref">pull</span></a> : pull an image from Docker or Singularity Hub</li>
<li><a class="reference internal" href="appendix.html#run-command"><span class="std std-ref">run</span></a> : Run your image as an executable</li>
<li><a class="reference internal" href="appendix.html#shell-command"><span class="std std-ref">shell</span></a> : Shell into your image</li>
</ul>
<p><strong>Image Commands</strong></p>
<ul class="simple">
<li><a class="reference internal" href="appendix.html#image-import"><span class="std std-ref">image.import</span></a> : import layers or other file content to your image</li>
<li><a class="reference internal" href="appendix.html#image-export"><span class="std std-ref">image.export</span></a> : export the contents of the image to tar or stream</li>
<li><a class="reference internal" href="appendix.html#image-create"><span class="std std-ref">image.create</span></a> : create a new image, using the old ext3 filesystem</li>
<li><a class="reference internal" href="appendix.html#image-expand"><span class="std std-ref">image.expand</span></a> : increase the size of your image (old ext3)</li>
</ul>
<div class="line-block">
<div class="line"><strong>Instance Commands</strong></div>
<div class="line">Instances were added in 2.4. This list is brief, and likely to expand
with further development.</div>
</div>
<ul class="simple">
<li><a class="reference internal" href="appendix.html#instance-command-group"><span class="std std-ref">instances</span></a> : Start, stop, and list container instances</li>
</ul>
<p><strong>Deprecated Commands</strong> The following commands are deprecated in 2.4 and
will be removed in future releases.</p>
<ul class="simple">
<li><a class="reference internal" href="appendix.html#bootstrap"><span class="std std-ref">bootstrap</span></a> : Bootstrap a container recipe</li>
</ul>
</div>
</div>
<div class="section" id="support">
<h2>Support<a class="headerlink" href="#support" title="Permalink to this headline">¶</a></h2>
<p>Have a question, or need further information? <a class="reference external" href="https://www.sylabs.io/contact/">Reach out to us</a>.</p>
</div>
<div class="section" id="about">
<h2>About<a class="headerlink" href="#about" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>While there are many container solutions being used commonly in this day and age, what makes Singularity different stems from it’s primary design features and thus it’s architecture:</p>
<ol class="arabic simple">
<li><strong>Reproducible software stacks:</strong> These must be easily verifiable via checksum or cryptographic signature in such a manner that does not change formats (e.g. splatting a tarball out to disk). By default Singularity uses a container image file which can be checksummed, signed, and thus easily verified and/or validated.</li>
<li><strong>Mobility of compute:</strong> Singularity must be able to transfer (and store) containers in a manner that works with standard data mobility tools (rsync, scp, gridftp, http, NFS, etc..) and maintain software and data controls compliancy (e.g. HIPAA, nuclear, export, classified, etc..)</li>
<li><strong>Compatibility with complicated architectures:</strong> The runtime must be immediately compatible with existing HPC, scientific, compute farm and even enterprise architectures any of which maybe running legacy kernel versions (including RHEL6 vintage systems) which do not support advanced namespace features (e.g. the user namespace)</li>
<li><strong>Security model:</strong> Unlike many other container systems designed to support trusted users running trusted containers we must support the opposite model of untrusted users running untrusted containers. This changes the security paradigm considerably and increases the breadth of use cases we can support.</li>
</ol>
</div>
<div class="section" id="background">
<h3>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h3>
<p>A Unix operating system is broken into two primary components, the kernel space, and the user space. The Kernel supports the user space by interfacing with the hardware, providing core system features and creating the software compatibility layers for the user space. The user space on the other hand is the environment that most people are most familiar with interfacing with. It is where applications, libraries and system services run.</p>
<p>Containers are shifting the emphasis away from the runtime environment by commoditizing the user space into swappable components. This means that the entire user space portion of a Linux operating system, including programs, custom configurations, and environment can be interchanged at runtime. Singularity emphasis and simplifies the distribution vector of containers to be that of a single, verifiable file.</p>
<p>Software developers can now build their stack onto whatever operating system base fits their needs best, and create distributable runtime encapsulated environments and the users never have to worry about dependencies, requirements, or anything else from the user space.</p>
<p>Singularity provides the functionality of a virtual machine, without the heavyweight implementation and performance costs of emulation and redundancy!</p>
<div class="section" id="the-singularity-solution">
<h4>The Singularity Solution<a class="headerlink" href="#the-singularity-solution" title="Permalink to this headline">¶</a></h4>
<p>Singularity has two primary roles:</p>
<ol class="arabic simple">
<li><strong>Container Image Generator:</strong> Singularity supports building different container image formats from scratch using your choice of Linux distribution bases or leveraging other container formats (e.g. Docker Hub). Container formats supported are the default compressed immutable (read only) image files, writable raw file system based images, and sandboxes (chroot style directories).</li>
<li><strong>Container Runtime:</strong> The Singularity runtime is designed to leverage the above mentioned container formats and support the concept of untrusted users running untrusted containers. This counters the typical container runtime practice of trusted users running trusted containers and as a result of that, Singularity utilizes a very different security paradigm. This is a required feature for implementation within any multi-user environment.</li>
</ol>
<p>The Singularity containers themselves are purpose built and can include a simple application and library stack or a complicated work flow that can interface with the hosts resources directly or run isolated from the host and other containers. You can even launch a contained work flow by executing the image file directly! For example, assuming that <code class="docutils literal notranslate"><span class="pre">~/bin</span></code> is in the user’s path as it is normally by default:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ mkdir ~/bin

$ singularity build ~/bin/python-latest docker://python:latest

Docker image path: index.docker.io/library/python:latest

Cache folder set to /home/gmk/.singularity/docker

Importing: base Singularity environment

Importing: /home/gmk/.singularity/docker/sha256:aa18ad1a0d334d80981104c599fa8cef9264552a265b1197af11274beba767cf.tar.gz

Importing: /home/gmk/.singularity/docker/sha256:15a33158a1367c7c4103c89ae66e8f4fdec4ada6a39d4648cf254b32296d6668.tar.gz

Importing: /home/gmk/.singularity/docker/sha256:f67323742a64d3540e24632f6d77dfb02e72301c00d1e9a3c28e0ef15478fff9.tar.gz

Importing: /home/gmk/.singularity/docker/sha256:c4b45e832c38de44fbab83d5fcf9cbf66d069a51e6462d89ccc050051f25926d.tar.gz

Importing: /home/gmk/.singularity/docker/sha256:b71152c33fd217d4408c0e7a2f308e66c0be1a58f4af9069be66b8e97f7534d2.tar.gz

Importing: /home/gmk/.singularity/docker/sha256:c3eac66dc8f6ae3983a7f37e3da84a8acb828faf909be2d6649e9d7c9caffc28.tar.gz

Importing: /home/gmk/.singularity/docker/sha256:494ffdf1660cdec946ae13d6b726debbcec4c393a7eecfabe97caf3961f62c36.tar.gz

Importing: /home/gmk/.singularity/docker/sha256:f5ec737c23de3b1ae2b1ce3dce1fd20e0cb246e4c73584dcd4f9d2f50063324e.tar.gz

Importing: /home/gmk/.singularity/metadata/sha256:5dd22488ce22f06bed1042cc03d3efa5a7d68f2a7b3dcad559df4520154ef9c2.tar.gz

WARNING: Building container as an unprivileged user. If you run this container as root

WARNING: it may be missing some functionality.

Building Singularity image...

Cleaning up...

Singularity container built: /home/gmk/bin/python-latest


$ which python-latest

/home/gmk/bin/python-latest


$ python-latest --version

Python 3.6.3


$ singularity exec ~/bin/python-latest cat /etc/debian_version

8.9

$ singularity shell ~/bin/python-latest

Singularity: Invoking an interactive shell within container...


Singularity python-latest:~&gt;
</pre></div>
</div>
<p>Additionally, Singularity blocks privilege escalation within the container and you are always yourself within a container! If you want to be root inside the container, you first must be root outside the container. This simple usage paradigm mitigates many of the security concerns that exists with containers on multi-user shared resources. You can directly call programs inside the container from outside the container fully incorporating pipes, standard IO, file system access, X11, and MPI. Singularity images can be seamlessly incorporated into your environment.</p>
</div>
<div class="section" id="portability-and-reproducibility">
<h4>Portability and Reproducibility<a class="headerlink" href="#portability-and-reproducibility" title="Permalink to this headline">¶</a></h4>
<p>Singularity containers are designed to be as portable as possible, spanning many flavors and vintages of Linux. The only known limitation is binary compatibility of the kernel and container. Singularity has been ported to distributions going as far back as RHEL 5 (and compatibles) and works on all currently living versions of RHEL, Debian, Arch, Alpine, Gentoo and Slackware. Within the container, there are almost no limitations aside from basic binary compatibility.</p>
<p>Inside the container, it is also possible to have a very old version of Linux supported. The oldest known version of Linux tested was a Red Hat Linux 8 container, that was converted by hand from a physical computer’s hard drive as the 15 year old hardware was failing. The container was transferred to a new installation of Centos7, and is still running in production!</p>
<p>Each Singularity image includes all of the application’s necessary run-time libraries and can even include the required data and files for a particular application to run. This encapsulation of the entire user-space environment facilitates not only portability but also reproducibility.</p>
</div>
</div>
<div class="section" id="features">
<h3>Features<a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h3>
<div class="section" id="encapsulation-of-the-environment">
<h4>Encapsulation of the environment<a class="headerlink" href="#encapsulation-of-the-environment" title="Permalink to this headline">¶</a></h4>
<p>Mobility of Compute is the encapsulation of an environment in such a manner to make it portable between systems. This operating system environment can contain the necessary applications for a particular work-flow, development tools, and/or raw data. Once this environment has been developed it can be easily copied and run from any other Linux system.</p>
<p>This allows users to BYOE (Bring Their Own Environment) and work within that environment anywhere that Singularity is installed. From a service provider’s perspective we can easily allow users the flexibility of “cloud”-like environments enabling custom requirements and workflows.</p>
<p>Additionally there is always a misalignment between development and production environments. The service provider can only offer a stable, secure tuned production environment which in many times will not keep up with the fast paced requirements of developers. With Singularity, you can control your own development environment and simply copy them to the production resources.</p>
</div>
<div class="section" id="containers-are-image-based">
<h4>Containers are image based<a class="headerlink" href="#containers-are-image-based" title="Permalink to this headline">¶</a></h4>
<p>Using image files have several key benefits:</p>
<p>First, this image serves as a vector for mobility while retaining permissions of the files within the image. For example, a user may own the image file so they can copy the image to and from system to system. But, files within an image must be owned by the appropriate user. For example, ‘/etc/passwd’ and ‘/’ must be owned by root to achieve appropriate access permission. These permissions are maintained within a user owned image.</p>
<p>There is never a need to build, rebuild, or cache an image! All IO happens on an as needed basis. The overhead in starting a container is in the thousandths of a second because there is never a need to pull, build or cache anything!</p>
<p>On HPC systems a single image file optimizes the benefits of a shared parallel file system! There is a single metadata lookup for the image itself, and the subsequent IO is all directed to the storage servers themselves. Compare this to the massive amount of metadata IO that would be required if the container’s root file system was in a directory structure. It is not uncommon for large Python jobs to DDOS (distributed denial of service) a parallel meta-data server for minutes! The Singularity image mitigates this considerably.</p>
</div>
<div class="section" id="no-user-contextual-changes-or-root-escalation-allowed">
<h4>No user contextual changes or root escalation allowed<a class="headerlink" href="#no-user-contextual-changes-or-root-escalation-allowed" title="Permalink to this headline">¶</a></h4>
<p>When Singularity is executed, the calling user is maintained within the container. For example, if user ‘gmk’ starts a Singularity container, the same user ‘gmk’ will end up within the container. If ‘root’ starts the container, ‘root’ will be the user inside the container.</p>
<p>Singularity also limits a user’s ability to escalate privileges within the container. Even if the user works in their own environment where they configured ‘sudo’ or even removed root’s password, they will not be able to ‘sudo’ or ‘su’ to root. If you want to be root inside the container, you must first be root outside the container.</p>
<p>Because of this model, it becomes possible to blur the line of access between what is contained and what is on the host as Singularity does not grant the user any more access than they already have. It also enables the implementation on shared/multi-tenant resources.</p>
</div>
<div class="section" id="no-root-owned-daemon-processes">
<h4>No root owned daemon processes<a class="headerlink" href="#no-root-owned-daemon-processes" title="Permalink to this headline">¶</a></h4>
<p>Singularity does not utilize a daemon process to manage the containers. While daemon processes do facilitate certain types of workflows and privilege escalation, it breaks all resource controlled environments. This is because a user’s job becomes a subprocess of the daemon (rather than the user’s shell) and the daemon process is outside of the reach of a resource manager or batch scheduler.</p>
<p>Additionally, securing a root owned daemon process which is designed to manipulate the host’s environment becomes tricky. In currently implemented models, it is possible to grant permissions to users to control the daemon, or not. There is no sense of ACL’s or access of what users can and can not do.</p>
<p>While there are some other container implementations that do not leverage a daemon, they lack other features necessary to be considered as reasonable user facing solution without having root access. For example, there has been a standing unimplemented patch to RunC (already daemon-less) which allows for root-less usage (no root). But, user contexts are not maintained, and it will only work with chroot directories (instead of an image) where files must be owned and manipulated by the root user!</p>
</div>
</div>
<div class="section" id="use-cases">
<h3>Use Cases<a class="headerlink" href="#use-cases" title="Permalink to this headline">¶</a></h3>
<div class="section" id="byoe-bring-your-own-environment">
<h4>BYOE: Bring Your Own Environment<a class="headerlink" href="#byoe-bring-your-own-environment" title="Permalink to this headline">¶</a></h4>
<p>Engineering work-flows for research computing can be a complicated and iterative process, and even more so on a shared and somewhat inflexible production environment. Singularity solves this problem by making the environment flexible.</p>
<p>Additionally, it is common (especially in education) for schools to provide a standardized pre-configured Linux distribution to the students which includes all of the necessary tools, programs, and configurations so they can immediately follow along.</p>
</div>
<div class="section" id="reproducible-science">
<h4>Reproducible science<a class="headerlink" href="#reproducible-science" title="Permalink to this headline">¶</a></h4>
<p>Singularity containers can be built to include all of the programs, libraries, data and scripts such that an entire demonstration can be contained and either archived or distributed for others to replicate no matter what version of Linux they are presently running.</p>
<p>Commercially supported code requiring a particular environment Some commercial applications are only certified to run on particular versions of Linux. If that application was installed into a Singularity container running the version of Linux that it is certified for, that container could run on any Linux host. The application environment, libraries, and certified stack would all continue to run exactly as it is intended.</p>
<p>Additionally, Singularity blurs the line between container and host such that your home directory (and other directories) exist within the container. Applications within the container have full and direct access to all files you own thus you can easily incorporate the contained commercial application into your work and process flow on the host.</p>
</div>
<div class="section" id="static-environments-software-appliances">
<h4>Static environments (software appliances)<a class="headerlink" href="#static-environments-software-appliances" title="Permalink to this headline">¶</a></h4>
<p>Fund once, update never software development model. While this is not ideal, it is a common scenario for research funding. A certain amount of money is granted for initial development, and once that has been done the interns, grad students, post-docs, or developers are reassigned to other projects. This leaves the software stack un-maintained, and even rebuilds for updated compilers or Linux distributions can not be done without unfunded effort.</p>
</div>
<div class="section" id="legacy-code-on-old-operating-systems">
<h4>Legacy code on old operating systems<a class="headerlink" href="#legacy-code-on-old-operating-systems" title="Permalink to this headline">¶</a></h4>
<p>Similar to the above example, while this is less than ideal it is a fact of the research ecosystem. As an example, I know of one Linux distribution which has been end of life for 15 years which is still in production due to the software stack which is custom built for this environment. Singularity has no problem running that operating system and application stack on a current operating system and hardware.</p>
</div>
<div class="section" id="complicated-software-stacks-that-are-very-host-specific">
<h4>Complicated software stacks that are very host specific<a class="headerlink" href="#complicated-software-stacks-that-are-very-host-specific" title="Permalink to this headline">¶</a></h4>
<p>There are various software packages which are so complicated that it takes much effort in order to port, update and qualify to new operating systems or compilers. The atmospheric and weather applications are a good example of this. Porting them to a contained operating system will prolong the use-fullness of the development effort considerably.</p>
</div>
<div class="section" id="complicated-work-flows-that-require-custom-installation-and-or-data">
<h4>Complicated work-flows that require custom installation and/or data<a class="headerlink" href="#complicated-work-flows-that-require-custom-installation-and-or-data" title="Permalink to this headline">¶</a></h4>
<p>Consolidating a work-flow into a Singularity container simplifies distribution and replication of scientific results. Making containers available along with published work enables other scientists to build upon (and verify) previous scientific work.</p>
</div>
</div>
<div class="section" id="license">
<h3>License<a class="headerlink" href="#license" title="Permalink to this headline">¶</a></h3>
<p>Singularity is released under a standard 3 clause BSD license.
Please see our <a class="reference external" href="https://github.com/singularityware/singularity/blob/master/LICENSE.md">LICENSE</a> file for more details).</p>
</div>
<div class="section" id="getting-started">
<h3>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h3>
<p>Jump in and <a class="reference internal" href="quick_start.html#quick-start"><span class="std std-ref">get started</span></a>, or find ways to get <a class="reference external" href="https://www.sylabs.io/contact/">help</a>.</p>
<ul class="simple">
<li>Project lead: <a class="reference external" href="https://gmkurtzer.github.io/">Gregory M. Kurtzer</a></li>
</ul>
</div>
</div>
</div>


           </div>

          </div>
          <footer>

    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">

        <a href="installation.html" class="btn btn-neutral float-right" title="Installation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>


        <a href="quick_start.html" class="btn btn-neutral" title="Quick Start" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>

    </div>


  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Singularity.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>


<script type="text/javascript" src="_static/js/footer.js"></script>


    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.6',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>



  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

</body>
</html>
